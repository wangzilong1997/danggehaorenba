'use strict'

const http2 = require('http2')
const fs = require('fs')

let httpc = function () {

  if ( !(this instanceof httpc) ) {
    return httpc()
  }

  this.logger = null
  this.config = null
  this.fpurl = null
  this.host = '';
}

/**
 * 
 * @param {object} app titbit实例
 */

httpc.prototype.init = function (app) {

  if (app.httpServ.fpurl === undefined) {
    throw new Error(`please update your titbit to latest version "^21.10.1".`)
  }

  if (app.config.http2) {
    throw new Error(`set app.config.http2=false and restart.`)
  }

  app.config.server.allowHTTP1 = true

  app.httpServ.run = this.run

  app.httpServ.onRequest = this.onRequest

}

httpc.prototype.onRequest = function () {

  let self = this

  let callback = (req, res) => {

    req.on('error', (err) => {
      self.requestError(err, req, res)
    })

    res.on('error', (err) => {
      self.requestError(err, res, req)
    })

    let remote_ip = req.socket.remoteAddress || ''

    if (self.config.globalLog) {
      
      let real_ip = '-'
      if (self.config.realIP) {
        real_ip = req.headers['x-real-ip'] || req.headers['x-forwarded-for'] || '-'
      }

      res.on('finish', () => {
        
        if (req.httpVersion[0] === '1') {

          self.logger({
            method : req.method,
            status : res.statusCode,
            ip : remote_ip,
            link: `https://${req.headers['host'] || self.host}${req.url}`,
            agent : req.headers['user-agent'] || '-',
            real_ip : real_ip,
          })

        } else {

          if (res.stream.rstCode == http2.constants.NGHTTP2_NO_ERROR) {
            self.logger({
              method : req.method,
              status : res.statusCode,
              ip : remote_ip,
              link : `https://${req.authority}${req.url}`,
              agent : req.headers['user-agent'] || '-',
              real_ip : real_ip,
            })
          }

        }

      })

    }

    if (req.url.length > self.config.maxUrlLength) {
      req.url = req.url.substring(0, self.config.maxUrlLength)
    }

    let urlobj = self.fpurl(req.url, self.config.autoDecodeQuery,
                    self.config.fastParseQuery,
                    self.config.maxQuery)

    let rt = self.router.findRealPath(urlobj.path, req.method)

    if (rt === null) {
      res.statusCode = 404
      res.end(self.config.notFound)
      return
    }

    let ctx = self.ctxpool.getctx() || new self.context()

    if (req.httpVersion[0] === '1') {
      ctx.version = '1.1'
      ctx.major = 1
      ctx.host = req.headers['host'] || self.host
    } else {
      ctx.version = '2'
      ctx.major = 2
      ctx.host = req.authority
    }

    ctx.bodyLength = 0
    ctx.maxBody = self.config.maxBody
    ctx.service = self.service

    ctx.method = req.method
    ctx.protocol = 'https'
    ctx.ip = remote_ip

    ctx.port = req.socket.remotePort
    ctx.request = req
    ctx.response = res
    ctx.reply = ctx.response
    ctx.headers = req.headers

    ctx.path = urlobj.path
    ctx.query = urlobj.query
    ctx.routepath = rt.key
    ctx.requestCall = rt.reqcall.reqCall
    ctx.name = rt.reqcall.name
    ctx.group = rt.reqcall.group
    ctx.param = rt.args
    rt = null

    return self.midware.run(ctx).finally(()=>{
      self.ctxpool.free(ctx)
      ctx = null
    })

  }

  return callback

}

/** 
   * 运行HTTP/1.1服务
   * @param {number} port 端口号
   * @param {string} host IP地址，可以是IPv4或IPv6
   * 0.0.0.0 对应使用IPv6则是::
  */
 
httpc.prototype.run = function (port, host) {
  
  var self = this

  var serv = null

  if (this.config.key && this.config.cert) {
    this.config.server.key  = fs.readFileSync(this.config.key)
    this.config.server.cert = fs.readFileSync(this.config.cert)
  }

  this.config.server.allowHTTP1 = true
  
  serv = http2.createSecureServer(this.config.server, this.onRequest())

  serv.on('tlsClientError', (err, tls) => {

    if (self.config.debug) {
      console.error('--DEBUG-TLS-CLIENT--:', err)
    }

    if (!tls.destroyed) {
      tls.destroy()
    }
    
  })

  serv.on('secureConnection', (sock) => {

    sock.on('error', err => {
      if (self.config.debug) {
        console.error('--DEBUG--CONNECTION--', err)
      }
    })
  })

  serv.on('clientError', (err, sock) => {
    if (!sock.destroyed) {
      sock.destroy()
    }
  })

  serv.on('unknownProtocol', tls_sock => {
    if (!tls_sock.destroyed) {
      tls_sock.destroy()
    }
  })

  serv.on('error', (e) => {
    if (e.code === 'EADDRINUSE') {
      if (process.send !== undefined && typeof process.send === 'function') {
        process.send({type: '_eaddr'}, (err) => {})
      } else {
        console.error('该端口已被使用，请先停止进程')
        process.exit(1)
      }
    }
  })
  
  serv.setTimeout(this.config.timeout, (sock) => {

    if (!sock.destroyed) {
      sock.destroy()
    }

  })
  
  for(let k in this.events) {
    if (typeof this.events[k] !== 'function') {
      continue
    }

    serv.on(k, this.events[k])
  }

  this.events = {}
 
  //说明是使用unix socket模式监听服务
  if (typeof port === 'string' && port.indexOf('.sock') > 0) {
    serv.listen(port)
  } else {
    serv.listen(port, host)
  }

  return serv
}

module.exports = httpc
