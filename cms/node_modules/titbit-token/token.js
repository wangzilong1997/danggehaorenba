'use strict'

const crypto = require('crypto')

let _randstrList = [
  'a', 'b', 'c', 'd', 'e', 'f', 'g',
  'h', 'i', 'j', 'k', 'l', 'm', 'n',
  'o', 'p', 'q', 'r', 's', 't', 'u',
  'v', 'w', 'x', 'y', 'z',

  '1', '2', '3', '4', '5', '6', '7', '8', '9'
]

function randstring(length = 8) {
  let rstr = ''
  let ind = 0

  for (let i = 0; i < length; i++) {
    ind = parseInt(Math.random() * _randstrList.length)
    rstr += _randstrList[ind]
  }
  return rstr
}

class token {

  constructor (options = {}) {
    
    this.iv = '1234569087123456'

    this.key = '123456789012435678901234567809qw'

    this.tokenEncoding = 'base64'

    this.urlEncoded = true

    //默认3小时有效
    this.expires = 10800000

    this.refresh = 0

    /**
     * tokenId用于识别token是否有效，如果发现token存在泄漏的可能，则在服务运行时，即可更改此值。
     * 此时，再次验证token则会失效。
     * */

    this.tokenMap = new Map()

    this.idKeyIV = new Map()

    this.tokenIds = []

    this.idIndex = -1

    if (typeof options !== 'object') {
      options = {}
    }

    for (let k in options) {
      switch (k) {
        case 'iv':
          this.iv = options[k]
          break
          
        case 'key':
          this.key = options[k]
          break

        case 'expires':
          if (typeof options[k] === 'number' && options[k] > 0) {
            this.expires = parseInt(options[k] * 1000)
          }
          break
        
        case 'encoding':
          this.tokenEncoding = options[k]
          break

        case 'urlEncoded':
        case 'urlencoded':
          this.urlEncoded = options[k]
          break

      }
    }


  }

  _aesEncrypt (data, key, iv, options = {}) {
    var h = crypto.createCipheriv('aes-256-cbc', key, iv, options)
    let hd = h.update(data, 'utf8', this.tokenEncoding)
    hd += h.final(this.tokenEncoding)
    return hd
  }

  _aesDecrypt (data, key, iv, options = {}) {
    var h = crypto.createDecipheriv('aes-256-cbc', key, iv, options)
    let hd = h.update(data, this.tokenEncoding, 'utf8')
    hd += h.final('utf8')
    return hd
  }

  addTokenId (tid) {
    if (typeof tid === 'string') {
      tid = [ tid ]
    }

    if (tid.toString() === '[object Object]') {

      for (let k in tid) {
        if (this.tokenIds.indexOf(k) < 0) {
          this.tokenIds.push(k)
          this.setMapId(k, tid[k])
        }
      }

    } else if (tid instanceof Array) {

      for (let i=0; i < tid.length; i++) {
        if (this.tokenIds.indexOf(tid[i]) < 0) {
          this.tokenIds.push(tid[i])
          this.tokenMap.set(tid[i], this.tokenIds.length)
        }
      }

    }

  }

  setMapId(tid, iv = null) {
    this.tokenMap.set(tid, iv || tid)
  }

  /**
   * 
   * @param {string} id 
   * @param {string} key 
   * @param {string} id 
   */
  setIdKeyIv (id, key, iv) {
    if (key.length !== 32 && iv.length !== 16) {
      throw new Error('key must be 32 bits, iv must be 16 bits.')
    }
    
    this.addTokenId(id)

    this.idKeyIV.set(id, {
      key : key,
      iv : iv,
      id : id,
    })
  }

  hasId (tid) {
    return this.tokenMap.has(tid)
  }

  /**
   * 允许tokenMap和tokenIds不一致，这种情况是针对以下需求设计：
   *    验证token是有效的，但是却只针对某些用户签发，对其他用户是不会签发的，
   *    签发是通过make传递参数指定的。
   * 
   * @param {string} tid 
   */
  removeTokenId (tid) {
    let ind = this.tokenIds.indexOf(tid)

    if (ind >= 0) {
      this.tokenIds.splice(ind, 1)
    }

    this.tokenMap.delete(tid)
    this.idKeyIV.delete(tid)
  }

  randId () {
    if (this.tokenIds.length <= 0) {
      return ''
    }

    let ind = parseInt( Math.random() * this.tokenIds.length)

    return this.tokenIds[ind]
  }

  stepId () {
    if (this.tokenIds.length <= 0) {
      return ''
    }

    if (this.idIndex >= this.tokenIds.length - 1) {
      this.idIndex = -1
    }

    this.idIndex += 1

    return this.tokenIds[this.idIndex]
  }

  setIv (iv) {
    this.iv = iv
  }

  setKey (key) {
    this.key = key
  }

  setEncoding (ecode) {
    this.tokenEncoding = ecode
  }

  setExpires (expires) {
    this.expires = expires
  }

  setRefresh (flag = true) {
    if (flag) {
      this.refresh = parseInt(this.expires / 5)
    } else {
      this.refresh = 0
    }
  }

  refreshToken(t, ikv = null) {
    if (t.data.expires + t.data.timestamp - t.now < this.refresh) {
      if (ikv !== null) {
        return this.makeikv(t.data, ikv)
      }
      return this.make(t.data, t.data.tokenId)
    }
    return null
  }

  fmtToken (tk) {
    return tk.replace(/\//g, '.').replace(/\=/g, '~').replace(/\+/g, '-')
  }

  parseToken (edata) {
    return edata.replace(/\./g, '/').replace(/\~/g, '=').replace(/\-/g, '+')
  }

  /**
   * 
   * @param {object} userinfo 
   * 
   */

  make (userinfo, tokenId = null) {

    userinfo.expires = this.expires
    userinfo.timestamp = Date.now()

    userinfo.tokenId = tokenId || this.stepId()

    let tk

    let ikv = tokenId ? this.idKeyIV.get(tokenId) : null

    if (tokenId && ikv) {
      tk = this._aesEncrypt(JSON.stringify(userinfo), ikv.key, ikv.iv)
    } else {
      tk = this._aesEncrypt(JSON.stringify(userinfo), this.key, this.iv)
    }

    if (this.urlEncoded) {
      return this.fmtToken(tk)
    }

    return tk
  }

  randIvToken (info, id = null, key = null) {
    let riv = randstring(16)
    let tid = id || this.randId()
    let opts = {
      id : tid,
      key : key || this.key,
      iv : riv
    }

    let t = this.makeikv(info, opts)
    
    return {
      token : t,
      iv : riv,
      id : tid,
      key : opts.key
    }

  }

  makeikv (userinfo, ikv) {

    userinfo.expires = this.expires
    userinfo.timestamp = Date.now()

    userinfo.tokenId = ikv.id

    let tk = this._aesEncrypt(JSON.stringify(userinfo), ikv.key, ikv.iv)

    if (this.urlEncoded) {
      return this.fmtToken(tk)
    }

    return tk
  }

  verifyikv (edata, ikv) {
    return this.verify(edata, ikv.key, ikv.iv, ikv.id)
  }

  verifyid (edata, tid) {
    let tk = this.idKeyIV.get(tid)
    if (tk) {
      return this.verify(edata, tk)
    }
    return this.verify(edata)
  }

  verify (edata, ikv = {}) {

    if (this.urlEncoded) {
      edata = this.parseToken(edata)
    }

    try {

      let u = this._aesDecrypt(edata, ikv.key || this.key, ikv.iv || this.iv)

      let uj = JSON.parse(u)

      let tm = Date.now()

      if (uj.timestamp + uj.expires < tm) {
        return {
          ok : false,
          errcode : 'TIMEOUT'
        }
      }

      if (uj.tokenId !== '' && ( (ikv.id && uj.tokenId !== ikv.id) || !this.tokenMap.has(uj.tokenId)) )
      {
        return {
          ok : false,
          errcode : 'ILLEGAL'
        }
      }

      return {
        ok : true,
        data : uj,
        now : tm
      }

    } catch (err) {
      return {
        ok : false,
        errcode : 'FAILED'
      }
    }

  }

  mid () {
    let self = this

    return async (c, next) => {
      let token = c.headers['authorization'] || c.query.token

      if (!token) {
        c.status(403)
        c.res.body = 'deny'
        return
      }

      let uinfo = self.verify(token)

      if (!uinfo.ok) {
        c.status(403)
        c.res.body = uinfo.errcode
        return
      }

      c.box.user = uinfo

      if (uinfo.data.expires + uinfo.data.timestamp - uinfo.now < self.refresh) {
        let new_token = self.make(uinfo.data, uinfo.data.tokenId)
        c.setHeader('refresh-token', new_token)
      }

      await next()

    }
  }

}

module.exports = token
